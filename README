This is a sample Backbone app using MySQL, Node and Express. To run it, you must install Node:

http://nodejs.org/download/

You will also need an instance of MySQL running locally. Run this script to create the db and related table:

CREATE DATABASE tech_test

CREATE USER 'sec_user'@'localhost' IDENTIFIED BY 'eKcGZr59zAa2BEWU';
GRANT SELECT, INSERT, UPDATE ON `tech_test`.* TO 'sec_user'@'localhost';

CREATE TABLE `tech_test`.`users` (
    `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `username` VARCHAR(30) NOT NULL,
    `email` VARCHAR(50) NOT NULL,
    `password` CHAR(88) NOT NULL,
    `salt` CHAR(24) NOT NULL,
    `city` VARCHAR(50) NOT NULL,
    `state` CHAR(2) NOT NULL,
    `gender` CHAR(1) NOT NULL,
    `age` INT NOT NULL
) ENGINE = InnoDB;

You may have to adjust the port that MySQL is expected to run under in the app. There are TODO: comments next to the port number in the server.js file.

Once you have installed Node and have MySQL running, you should be able to navigate to the solution's root folder on your local machine via a terminal app.

In that folder in a terminal, type:

node server

to start the app.

The app should then be running under:

//localhost:3000

Available endpoints on the API are:

/api/login
/api/users
/api/files/:directory

All endpoints accept POSTed data, or querystring, if you want to test the POST routes with Postman

The "files" endpoint requires a URL parameter listing which sub-folder(s) under the solution root folder to query:

/api/files/clientapp/models

will list all the JavaScript model files for the app.

The API routes are unsecured, which is regrettable, but this exercise took a little too much time.

Healhcheck:

http://localhost:3000/ping

This URL provides a JSON object with all the app's vital stats. I would have liked to make this page less ugly, but again, this exercise took a good amount of time to put together.

Notes on tech stack choices:

backbone - used as a display layer JavaScript MVC. It was used because it is very basic and doesn' require too much configy stuff to get an app up and running quickly
body-parser = a plugin which allows express.js to "read" POSTed values
browserify and browserify-middleware - very powerful plugin, similar to GRUNT. browserify allows all clientside modules to make require()-like dependency calls and reuse libraries included in the Node / Express app
crypto-js - no one should EVER store passwords in plain text, ever. crypto-js was used to store individually salted hashes of the users' passwords in the db
express - used as the server app to both response to API calls, and act as a entrypoint for the client app, as well as packing all files and dependencies
jade - HTML templating
jquery = because jQuery
ms - dependency for browserify
mysql - db solution
prepare-response - dependency for browserify
templatizer - converts all .jade html template files into executable JavaScript functions for very fast usage in the client (no compiling HTML templates "on the fly")
uglify - dependency for browserify to obfuscate code (not implemented)

Things I skipped:

The user filters and clunky and don't have a GroupBy option in the UI. Again, this took too much time to complete.
Also, the clientside filtering solution doesn't make a request to the server... backbone is perfecty happy doing the filtering on the client, but I DID build the filtering into the server endpoint.
You can use the API endpoint to see filtering and grouping of users:

//localhost:3000/api/users?filter=gender|M&group=state
//localhost:3000/api/users?filter=state|CA

However, I didn't want to take the time to dynamically Count() the fields in the SQL query if there is grouping, so the results are wonky

Pagination - not enough time. However, the API would accept query params for offset and number records to return.

API versioning - Not enough time to dedicate to a coding exercise...!
